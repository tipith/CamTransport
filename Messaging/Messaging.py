import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

import sys
import os
import threading
import config
import calendar
import time
import pickle
import logging
from . Message import Message, HeartbeatMessage


class BaseMessaging(threading.Thread):

    def __init__(self, up, down, heartbeat_enable):
        threading.Thread.__init__(self)
        self.is_running = True
        self.handlers = {}
        self.up = up
        self.down = down
        self.last_up = 0
        self.last_down = calendar.timegm(time.gmtime())
        self.last_retry = calendar.timegm(time.gmtime())
        self.retry_cnt = 0
        self.heartbeat_enable = heartbeat_enable

    def run(self):
        if self.down is not None:
            self.logger.info('started')
            while self.is_running:
                events = self.down.poll(timeout=1.0)
                self.logger.debug('poll')
                if events == zmq.POLLIN:
                    msg = self.wait()
                    if Message.verify(msg):
                        self.last_down = calendar.timegm(time.gmtime())
                        self.retry_cnt = 0
                        if msg['id'] == Message.Heartbeat:
                            self.logger.debug('heartbeat received')
                            continue
                        if msg['id'] in self.handlers:
                            self.logger.info('received %s' % Message.msg_info(msg))
                            self.handlers[msg['id']](msg)
                        if '*' in self.handlers:
                            self.handlers['*'](msg)
                else:
                    time.sleep(0.5)

                curr_time = calendar.timegm(time.gmtime())

                # send heartbeat to uplink
                if self.last_up + 10 < curr_time:
                    self.send(HeartbeatMessage())
                    self.logger.debug('heartbeat sent')

                # check received heartbeat status
                if self.heartbeat_enable and self.last_down + 300 < curr_time and self.last_retry + min(self.retry_cnt, 10) * 60 < curr_time:
                    time_since_msg = curr_time - self.last_down
                    time_since_retry = curr_time - self.last_retry
                    self.logger.warn('reconnect attempt %u. last msg %u s ago, last retry %s s ago' % (self.retry_cnt, time_since_msg, time_since_retry))
                    self.down.disconnect(self.down.LAST_ENDPOINT)
                    self.down.connect(self.down.LAST_ENDPOINT)
                    self.last_retry = curr_time
                    self.retry_cnt += 1

            self.down.close()
            self.logger.info('stopped')
        else:
            self.logger.warn('no downlink socket given. not starting receive thread')

    def wait(self):
        try:
            return self.down.recv_pyobj()
        except pickle.UnpicklingError as e:
            self.logger.error('Error: UnpicklingError')
            return None
        except (AttributeError, EOFError, ImportError, IndexError) as e:
            self.logger.error('Error: Other')
            return None
        except Exception as e:
            return None

    def send(self, msg, serialize=True):
        if self.up is not None:
            try:
                self.logger.debug('send {}'.format(msg))
                self.last_up = calendar.timegm(time.gmtime())
                return self.up.send_pyobj(msg.serialize() if serialize else msg, protocol=2)
            except zmq.ZMQError:
                self.logger.error('Error: unable to send msg')
                return None
        else:
            self.logger.warn('no uplink socket given. unable to send message')

    def install(self, frame, handler):
        self.handlers[frame] = handler

    def stop(self):
        self.is_running = False
        if self.up is not None:
            self.up.close()
        self.join(2.0)


def check_certificates():
    # These directories are generated by the generate_certificates script
    base_dir = os.path.dirname(__file__)
    keys_dir = os.path.join(base_dir, 'certificates')
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    secret_keys_dir = os.path.join(base_dir, 'private_keys')

    if not (os.path.exists(keys_dir) and os.path.exists(public_keys_dir) and os.path.exists(secret_keys_dir)):
        logging.critical("Certificates are missing - run generate_certificates.py script first")
        raise RuntimeError('certificates do not exist!')


def security_add(ctx, i_am_server, up, down):
    print('activate curve auth')
    base_dir = os.path.dirname(__file__)
    keys_dir = os.path.join(base_dir, 'certificates')
    public_keys_dir = os.path.join(base_dir, 'public_keys')
    secret_keys_dir = os.path.join(base_dir, 'private_keys')

    auth = ThreadAuthenticator(ctx)
    auth.start()
    #auth.allow('127.0.0.1')
    auth.configure_curve(domain='*', location=public_keys_dir)

    if i_am_server:
        server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
        server_public, server_secret = zmq.auth.load_certificate(server_secret_file)

        up.curve_secretkey = server_secret
        up.curve_publickey = server_public
        up.curve_server = True  # must come before bind
        down.curve_secretkey = server_secret
        down.curve_publickey = server_public
        down.curve_server = True  # must come before bind
    else:
        client_secret_file = os.path.join(secret_keys_dir, "client.key_secret")
        client_public, client_secret = zmq.auth.load_certificate(client_secret_file)

        up.curve_secretkey = client_secret
        up.curve_publickey = client_public
        down.curve_secretkey = client_secret
        down.curve_publickey = client_public

        server_public_file = os.path.join(public_keys_dir, "server.key")
        server_public, _ = zmq.auth.load_certificate(server_public_file)
        # The client must know the server's public key to make a CURVE connection.
        up.curve_serverkey = server_public
        down.curve_serverkey = server_public
    return auth


def security(auth_method):
    def decorator(cls):
        class Wrapper(object):
            def __init__(self, *args):
                print(self.__class__.__name__ + ' enter')
                self.wrapped = cls(*args)
                self.auth_method = auth_method
                if self.auth_method == 'curve':
                    check_certificates()  # raises RuntimeError if not found
                    self.auth = security_add(self.wrapped.context, self.wrapped.i_am_server, self.wrapped.up, self.wrapped.down)
                elif self.auth_method == 'none':
                    print('no auth')
                else:
                    raise TypeError('invalid auth method ' + str(auth_method))

                self.wrapped.activate_connection()
                print(self.__class__.__name__ + ' exit')

            def __getattribute__(self, s):
                try:
                    x = super(Wrapper, self).__getattribute__(s)
                except AttributeError:
                    pass
                else:
                    return x
                if self.auth_method == 'curve' and s == 'stop':
                    self.auth.stop()
                return self.wrapped.__getattribute__(s)

        return Wrapper
    return decorator


@security('curve')
class WanServer(BaseMessaging):

    def __init__(self):
        self.context = zmq.Context()
        downlink = self.context.socket(zmq.PULL)
        uplink = self.context.socket(zmq.PUB)
        BaseMessaging.__init__(self, uplink, downlink, False)

        self.name = self.__class__.__name__
        self.logger = logging.getLogger(self.name)
        self.i_am_server = True

    def activate_connection(self):
        incoming = "tcp://*:%i" % config.upload_port
        outgoing = "tcp://*:%i" % config.msg_port
        self.logger.info('listening incoming %s, outgoing %s' % (incoming, outgoing))

        self.down.bind(incoming)
        self.down.setsockopt(zmq.RCVTIMEO, 1000)
        self.up.bind(outgoing)


@security('curve')
class WanClient(BaseMessaging):

    def __init__(self):
        self.context = zmq.Context()
        uplink = self.context.socket(zmq.PUSH)
        downlink = self.context.socket(zmq.SUB)
        BaseMessaging.__init__(self, uplink, downlink, True)

        self.name = self.__class__.__name__
        self.logger = logging.getLogger(self.name)
        self.i_am_server = False

    def activate_connection(self):
        outgoing = "tcp://%s:%i" % (config.upload_ip, config.upload_port)
        incoming = "tcp://%s:%i" % (config.upload_ip, config.msg_port)
        self.logger.info('connecting outgoing %s, incoming %s' % (outgoing, incoming))

        self.up.connect(outgoing)
        self.down.connect(incoming)
        self.down.setsockopt(zmq.SUBSCRIBE, b'')
        self.down.setsockopt(zmq.RCVTIMEO, 1000)


class LocalServer(BaseMessaging):

    def __init__(self):
        self.context = zmq.Context()
        outgoing = "tcp://127.0.0.1:9996"
        incoming = "tcp://127.0.0.1:9997"

        # forwards messages locally from the cameras
        uplink = self.context.socket(zmq.PUB)
        uplink.bind(outgoing)

        # forwards messages locally to the cameras
        downlink = self.context.socket(zmq.PULL)
        downlink.bind(incoming)
        downlink.setsockopt(zmq.RCVTIMEO, 1000)

        super(LocalServer, self).__init__(uplink, downlink, False)
        self.name = self.__class__.__name__
        self.logger = logging.getLogger(self.name)
        # self.logger.info('listening to %s' % incoming)


class LocalClient(BaseMessaging):

    def __init__(self):
        self.context = zmq.Context()
        incoming = "tcp://127.0.0.1:9996"
        outgoing = "tcp://127.0.0.1:9997"

        # incoming messages from the cameras
        downlink = self.context.socket(zmq.SUB)
        downlink.connect(incoming)
        downlink.setsockopt(zmq.SUBSCRIBE, b'')
        downlink.setsockopt(zmq.RCVTIMEO, 1000)

        # incoming messages from the cameras
        uplink = self.context.socket(zmq.PUSH)
        uplink.connect(outgoing)

        super(LocalClient, self).__init__(uplink, downlink, False)
        self.name = self.__class__.__name__
        self.logger = logging.getLogger(self.name)
        # self.logger.info('connecting to %s' % outgoing)